#+TITLE: dev-notes
* git
** Install
*** Fedora
sudo yum install git
git config --global user.name "Jack Gill"
git config --global user.email jack@jackmgill.com
*** Ubuntu
sudo apt-get instlal g
*** Windows
Download windows installer:
http://git-scm.com/download
** push changes to github:
git push github master
** update local repo from github:
git pull github master
** add remote
git remote add github git@github.com:jackgill/Project-Euclid.git
* Ruby
** Install
*** Linux
use the bash snippet on the rvm home page:
http://beginrescueend.com/
install all of the rvm dependencies (specified in the shell output from the rvm installer)
rvm install 1.9.2
rvm use 1.9.2 --default
*** Windows
use the Rails Installer:
http://railsinstaller.org/
* sqlite
** to create a new database
sqlite3 foo.db
** to create a new table
create table name(x integer primary key, y text, z double, a date)
** list tables
sqlite3 db\development.sqlite3;
SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;
SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'table_name';
* postgres
** Install
*** Fedora
sudo yum install postgresql-server postgres-devel
su root
mkdir /usr/local/pgsql/data
chown postgres /usr/local/pgsql/data
su - postgres
initdb -D /usr/local/pgsql/data
pg_ctl start -D /usr/local/pgsql/data
createuser -P (create user euclid, password foo)
createuser -P (create user jack, password foo)
createdb euclid_development
** to start the database server: 
- postgres -D (path to data directory)
*** Windows
- C:\Users\Jack\PostgreSQL\9.1\bin\postgres.exe -D C:\Users\Jack\PostgreSQL\9.1\data
*** Ubuntu
- postgres -D ~/postgres_data/
*** Fedora
- sudo postgres
- postgres -D /usr/local/pgsql/data &
** connect to the database server: 
psql -d (database name) -U (user name)
psql -d euclid_development -U euclid
(password for user euclid is foo)
special bonus command:
psql -d euclid_development -U euclid -c "select * from Users;"
** set up new PG db
initially, connect as user 'postgres' and create a new role, a new database, and set privleges:
 psql -U postgres
 create user jack password 'password' (NOTE: user name will be lower-cased)
 create database (database name);
 grant all privileges on (database name) to (user name);
** to get the postgres db adapter for ruby:
sudo gem install pg
** restart postgres server process
pg_ctl restart -D C:\Users\Jack\PostgreSQL\9.1\data
pg_ctl restart -D /usr/local/pgsql/data/
** show columns
show columns \d (table name)
* emacs
use nxhtml for syntax highlighting erb files
use M-x customize-group RET mumamo RET to change the background color
* project
bundle install
rake db:seed
* Heroku
** Install
gem install heroku
git remote add heroku git@heroku.com:electric-lightning-9621.git
heroku keys:add
** create new heroku app
heroku create --stack cedar
** deploy new version to heroku
git push heroku master
** run database migration on heroku db
heroku run rake db:migrate
** open site on heroku
heroku open
http://electric-lightning-9621.heroku.com/
* Rails
** Install
*** Linux
gem install rails
*** Windows
Use the Rails Installer:
http://railsinstaller.org/
** generate a database migration to add a column to an existing table
rails generate migration AddColumnToTable column:type
rails generate migration AddIsAdminToUsers is_admin:boolean
** generate a controller
rails generate controller account login logout
** Response.Write from controller
render :text => "hello"
** scaffolding
rails generate scaffold user first_name:string last_name:string email:string login:string hashed_password:string salt:string
rails generate scaffold building name:string address:text
rails generate scaffold spot building_id:integer number:integer floor:integer owner_id:integer
rails generate scaffold request requester_id:integer start_date:date end_date:date bid_price:decimal
rails generate scaffold transaction spot_id:integer buyer_id:integer seller_id:integer start_date:date end_date:date price:decimal
rails generate scaffold availability listing_id:integer building_id:integer start_date:date end_date:date
* Business
What is a business?
An LLC.
A memorandum of understanding?
It has:
- a domain
- email
- a mailing address, usually a PO Box
- a web site
- a phone number?
When you start a small business, the LLC is a legal shim that stands between you and liability. 
The various means to contacts a business - email, phone, snail mail - all fall through to the personal
equivalents for the founders. 
Likewise, the income and taxes fall through to the founders.

So when you start an LLC, you're basically creating a thin layer between your person and the rest of 
the world.

Need to do some cost projections based on various hosting scenarios.
Need to research these hosting providers in depth: Heroku, Engine Yard, EC2. (others: Rackspace, Linode) 
Need to write a position paper on PaaS vs IaaS.
Need to do some revenue projections based on usage volume, and our cut.

cost project + revenue = rudimentary business model?

* Brainstorming
** counter offers:
field for transaction owner
two fields for each party assenting to the transaction
facilitate counter offers by resetting "owner" field
transaction is complete when both parties assent
TODO: mutable or immutable transactions?
* Features
** messaging -- release valve
** link-to-listing
** lightning offers
** transaction queue (on user dashboard)
** fine-grained management of notifications
** private offer facility
** partial availability
- availability by the day, the day is defined as 10am - 10am, w/ a button to request late check in / check out
- listing partial availability: introduce a "day" resource, each listing has multiple days.
- alternatively, stick w/ single listings, and reference a "taken" table -- everything runs off timestamps

taken needs  foreign key to listings

# create tables
create table listings(id integer primary key, start_date date, end_date date);
create table taken(id integer primary key, start_date date, end_date date, foreign key(id) references listings(id));

# insert some dummy data
insert into listings (start_date, end_date) values('2012-01-01', '2012-01-02');
insert into listings (start_date, end_date) values('2012-01-01', '2012-01-12');
insert into taken (start_date, end_date, listing_id) values('2012-01-03', '2012-01-08', 2);

query (listings + taken) for available time slots
two step query:
retrieve all listings meeting query criteria
for each listing, retrieve taken entries using foreign key
(this will be SLOW)
what to return?
pseudo-listings?

business requirement: 
users can create listings for arbitrary time periods
other users can taken arbitrary subsets of these listings
but me must still be able to efficiently query for available listings



------------------
chunks
day-sized chunks
each chunk has a listing id
this makes it easy to reconstitute a listing from its chunks

wait a minute
what about a table called days
each day w/ a reference to a listing
and/or a taken entry

calendar-per-building?
each day entry would need a list of listings and a list of taken
no...
you would pull a listing id off a day when it's taken

----------------------
currently "Taken" is a boolean property of listing
should it instead be a date range
should we introduce additional "available" date ranges?
should a listing advertise when it has availability?
zero more availability ranges
(perhaps we should be thinking in terms of storing "Taken", since after all we want to query on availability)
multiple rows per listing w/ different availabilities?
or just a separate availability table, w/ a foreign key to listings?
when taking availabily, computer appropriate alterations to availability table
need a separate "rentals" table? or is "transactions" covering that?

so on insert, fragment availability table? seems bogus.

essentially, the problem is how to represent time intervals, sub-intervals, and efficient querying on the difference between the two.

the key to efficiency seems to be pre-computing the desired quantity and representing it compactly.

the desired quantity is availability, not "taken-ness", so that's what we should be pre-computing and storing. the question is the most efficient format for storing availability? From a query perspective, we're doing fine with time spans

I'm thinking of an interval as being defined by its endpoints, but postgres seems to think of it as an offset and a length

I think I've got the most efficient query syntax possible

so the key this is the separation of a listing and availabilty
essentially, transforming "taken" from a bool to a set of ranges (and inverting that set of ranges)
the trick is to do the math on insert, which is expected to take a bit, and not on query, which is expected to be fast.

ok, so on creation of a listing, an availability entry is created, with date endpoints corresponding to the listing's endpoints.
when someone wants to "take" part of a listing, the initial availability entry is split into two new availability entries, with a gap corresponding to what's been "taken"
(each "take" action is limited to at most 1 deletion and 2 inserts)
querying of the availability table is still efficient since it doesn't require any addition calculations at query time.

now, how to do this w/ the rails ORM is rather a differ matter. presumably, create an Availability object. that should be that hard, actually.

SOLUTION:
so I need to generate a rails model for availability. it will have a foreign key to the listings table, a start date, and an end date. The spots search will target this table, doing a join into listings to get the display info.

On creation of a new listing, create a new availability entry with the same endpoints.

On creation of a transaction, delete the corresponding availability entry (or mark it as defunct?), and create two new availability objects corresponding to the remaining portions of the original availabilty object. 

oh god, gonna need update logic as well

* Misc
- only admin users should be able to view the admin controller
- account creation page
- if we're going to passing around URL parameters and whatnot, we're going to need an entitlements system
- transactions need to be hooked in
- need to validate date range on listing creation form

- then update "rent" to split the availability
you rent availability, not a listing
the search page needs to pass start_date and end_date to the show page, through to the "rent" action
basically, start date and end date need to come into the "Rent" action so that the availability can be split appropriately
separate form for "rent"?
